

# This file was *autogenerated* from the file dec.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_118641897764566817417551054135914458085151243893181692085585606712347004549784923154978949512746946759125187896834583143236980760760749398862405478042140850200893707709475167551056980474794729592748211827841494511437980466936302569013868048998752111754493558258605042130232239629213049847684412075111663446003 = Integer(118641897764566817417551054135914458085151243893181692085585606712347004549784923154978949512746946759125187896834583143236980760760749398862405478042140850200893707709475167551056980474794729592748211827841494511437980466936302569013868048998752111754493558258605042130232239629213049847684412075111663446003); _sage_const_0x7f33a035c6390508cee1d0277f4712bf01a01a46677233f16387fae072d07bdee4f535b0bd66efa4f2475dc8515696cbc4bc2280c20c93726212695d770b0a8295e2bacbd6b59487b329cc36a5516567b948fed368bf02c50a39e6549312dc6badfef84d4e30494e9ef0a47bd97305639c875b16306fcd91146d3d126c1ea476 = Integer(0x7f33a035c6390508cee1d0277f4712bf01a01a46677233f16387fae072d07bdee4f535b0bd66efa4f2475dc8515696cbc4bc2280c20c93726212695d770b0a8295e2bacbd6b59487b329cc36a5516567b948fed368bf02c50a39e6549312dc6badfef84d4e30494e9ef0a47bd97305639c875b16306fcd91146d3d126c1ea476); _sage_const_151441473357136152985216980397525591305875094288738820699069271674022167902643 = Integer(151441473357136152985216980397525591305875094288738820699069271674022167902643); _sage_const_15624342005774166525024608067426557093567392652723175301615422384508274269305 = Integer(15624342005774166525024608067426557093567392652723175301615422384508274269305)
# Branch and prune for the case with p and q bits known.
def _branch_and_prune_pq(N, p, q, p_, q_, i):
    if i == len(p) or i == len(q):
        yield p_, q_
    else:
        c1 = ((N - p_ * q_) >> i) & _sage_const_1 
        p_prev = p[i]
        q_prev = q[i]
        p_possible = [_sage_const_0 , _sage_const_1 ] if p_prev is None else [p_prev]
        q_possible = [_sage_const_0 , _sage_const_1 ] if q_prev is None else [q_prev]
        for p_bit, q_bit in product(p_possible, q_possible):
            # Addition modulo 2 is just xor.
            if p_bit ** q_bit == c1:
                p[i] = p_bit
                q[i] = q_bit
                yield from _branch_and_prune_pq(N, p, q, p_ | (p_bit << i), q_ | (q_bit << i), i + _sage_const_1 )

        p[i] = p_prev
        q[i] = q_prev



def factorize_pq(N, p, q):
    """
    Factorizes n when some bits of p and q are known.
    If at least 57% of the bits are known, this attack should be polynomial time, however, smaller percentages might still work.
    More information: Heninger N., Shacham H., "Reconstructing RSA Private Keys from Random Key Bits"
    :param N: the modulus
    :param p: partial p (PartialInteger)
    :param q: partial q (PartialInteger)
    :return: a tuple containing the prime factors
    """
    #assert p.bit_length == q.bit_length, "p and q should be of equal bit length."

    #p_bits = p.to_bits_le()
    p_bits = list('1?0?1?0?0?1?1?1?0?1?1?0?1?0?0?0?0?1?1?0?1?0?1?1?0?0?0?0?1?1?1?0?0?0?1?1?1?0?1?0?0?0?1?0?1?1?1?0?1?0?0?1?0?1?1?0?0?1?0?0?1?0?1?1?0?1?1?1?0?1?0?1?0?1?0?1?1?1?0?0?1?0?0?1?0?1?1?1?0?1?1?1?0?0?0?0?1?0?0?1?0?1?0?0?0?0?1?0?1?1?1?1?0?1?1?1?1?1?0?1?0?1?1?1?0?0?1?0?1?0?1?0?1?0?0?1?1?0?0?1?0?0?0?1?0?0?1?1?0?1?0?1?1?0?0?1?1?0?0?1?0?1?0?0?0?0?1?0?0?0?0?1?0?0?0?0?1?1?1?0?1?0?1?0?0?0?0?1?0?1?0?1?1?1?1?1?0?1?1?0?0?0?0?1?1?0?0?1?0?0?1?0?0?1?0?1?1?1?1?1?0?1?0?0?0?1?1?1?1?0?0?1?0?1?1?0?1?1?0?0?0?1?1?1?1?1?0?0?1?1?0?1?1?0?0?1?1')
    for i, b in enumerate(p_bits):
        p_bits[i] = None if b == '?' else int(b, _sage_const_2 )

    q_bits = list('?1?0?0?0?1?0?1?0?0?0?1?0?1?1?0?0?0?1?0?0?0?0?0?1?1?0?1?1?1?0?1?0?1?0?1?1?1?0?1?0?1?1?1?1?1?1?1?1?0?0?0?1?1?1?0?1?0?0?1?1?0?1?1?1?1?1?0?0?1?1?1?1?1?0?0?0?0?0?1?0?0?1?0?0?1?1?0?0?1?0?1?0?1?0?0?0?0?0?0?1?0?1?0?1?0?0?1?0?1?0?0?1?0?0?0?1?0?1?0?1?1?1?1?1?0?1?1?1?0?0?1?0?0?1?0?1?1?1?0?0?0?1?0?1?0?0?0?0?1?1?0?0?1?1?1?1?0?1?1?0?1?0?0?0?1?1?1?1?1?1?0?1?1?0?0?0?0?0?0?0?1?1?1?0?1?0?0?0?0?1?0?1?0?0?1?0?1?0?1?1?1?1?0?0?1?0?0?1?1?1?1?1?1?1?0?0?0?0?0?1?1?0?0?0?0?1?1?0?0?0?1?0?1?0?1?1?0?0?1?1?0?1?1?1?0?0?0?1?1?1?1?0?0?1?')
    #q_bits = q.to_bits_le()
    for i, b in enumerate(q_bits):
        q_bits[i] = None if b == '?' else int(b, _sage_const_2 )

    # p and q are prime, odd.
    p_bits[_sage_const_0 ] = _sage_const_1 
    q_bits[_sage_const_0 ] = _sage_const_1 

    print("Starting branch and prune algorithm...")
    for p, q in _branch_and_prune_pq(N, p_bits, q_bits, p_bits[_sage_const_0 ], q_bits[_sage_const_0 ], _sage_const_1 ):
        if p * q == N:
            return int(p), int(q)


n = _sage_const_118641897764566817417551054135914458085151243893181692085585606712347004549784923154978949512746946759125187896834583143236980760760749398862405478042140850200893707709475167551056980474794729592748211827841494511437980466936302569013868048998752111754493558258605042130232239629213049847684412075111663446003 
ct = _sage_const_0x7f33a035c6390508cee1d0277f4712bf01a01a46677233f16387fae072d07bdee4f535b0bd66efa4f2475dc8515696cbc4bc2280c20c93726212695d770b0a8295e2bacbd6b59487b329cc36a5516567b948fed368bf02c50a39e6549312dc6badfef84d4e30494e9ef0a47bd97305639c875b16306fcd91146d3d126c1ea476 
p = _sage_const_151441473357136152985216980397525591305875094288738820699069271674022167902643 
q = _sage_const_15624342005774166525024608067426557093567392652723175301615422384508274269305 

print(factorize_pq(n, p, q))

