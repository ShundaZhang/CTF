

# This file was *autogenerated* from the file dec.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_200 = Integer(200); _sage_const_0xc20d4f0792f162e3f3486f47c2c5b05696ba5c81ec09f5386bf741b7289b85e2d744559825a23b0ae094da214f3158344e5d5ba86fb1ecd1f40c8682a7bee55021eba772e23793001a38b9cccbfdc1d9316cccc3b79acd045c512b44e0f3697383958113a280791e17c23fe80fa38099e4907f70f4d228285aac69ed2d3bcf99 = Integer(0xc20d4f0792f162e3f3486f47c2c5b05696ba5c81ec09f5386bf741b7289b85e2d744559825a23b0ae094da214f3158344e5d5ba86fb1ecd1f40c8682a7bee55021eba772e23793001a38b9cccbfdc1d9316cccc3b79acd045c512b44e0f3697383958113a280791e17c23fe80fa38099e4907f70f4d228285aac69ed2d3bcf99); _sage_const_0xfe8984407b0816cc28e5ccc6bb73790000000000ca3806dd2cfdfc8d616b000000006109a4dbe3876b8d1b8adc9175dfba0e1ef318801648d60000000000a05b = Integer(0xfe8984407b0816cc28e5ccc6bb73790000000000ca3806dd2cfdfc8d616b000000006109a4dbe3876b8d1b8adc9175dfba0e1ef318801648d60000000000a05b); _sage_const_3 = Integer(3); _sage_const_16 = Integer(16); _sage_const_240 = Integer(240); _sage_const_352 = Integer(352); _sage_const_40 = Integer(40); _sage_const_32 = Integer(32); _sage_const_6 = Integer(6)#https://gist.github.com/chrsow/f766786bfcb0034d8c6c9372b822222c

class IIter:
    def __init__(self, m, n):
        self.m = m
        self.n = n
        self.arr = [_sage_const_0  for _ in range(n)]
        self.sum = _sage_const_0 
        self.stop = False
    
    def __iter__(self):
        return self

    def __next__(self):
        if self.stop:
            raise StopIteration
        ret = tuple(self.arr)
        self.stop = True
        for i in range(self.n - _sage_const_1 , -_sage_const_1 , -_sage_const_1 ):
            if self.sum == self.m or self.arr[i] == self.m:
                self.sum -= self.arr[i]
                self.arr[i] = _sage_const_0 
                continue
            
            self.arr[i] += _sage_const_1 
            self.sum += _sage_const_1 
            self.stop = False
            break
        return ret

def coppersmith(f, bounds, m=_sage_const_1 , t=_sage_const_1 ):
    n = f.nvariables()
    N = f.base_ring().cardinality()
    f /= f.coefficients().pop(_sage_const_0 ) #monic
    f = f.change_ring(ZZ)
    x = f.parent().objgens()[_sage_const_1 ] 

    g = []
    monomials = []
    Xmul = []
    for ii in IIter(m, n):
        k = ii[_sage_const_0 ]
        g_tmp = f**k * N**max(t-k, _sage_const_0 )
        monomial = x[_sage_const_0 ]**k
        Xmul_tmp = bounds[_sage_const_0 ]**k
        for j in range(_sage_const_1 , n):
            g_tmp *= x[j]**ii[j]
            monomial *= x[j]**ii[j]
            Xmul_tmp *= bounds[j]**ii[j]
        g.append(g_tmp)
        monomials.append(monomial)
        Xmul.append(Xmul_tmp)

    B = Matrix(ZZ, len(g), len(g))
    for i in range(B.nrows()):
        for j in range(i + _sage_const_1 ):
            if j == _sage_const_0 :
                B[i,j] = g[i].constant_coefficient()
            else:
                v = g[i].monomial_coefficient(monomials[j])
                B[i,j] = v * Xmul[j]

    print("LLL...")
    B = B.LLL()
    print("LLL finished")

    ###############################################

    print("polynomial reconstruction...")

    h = []
    for i in range(B.nrows()):
        h_tmp = _sage_const_0 
        for j in range(B.ncols()):
            if j == _sage_const_0 :
                h_tmp += B[i, j]
            else:
                assert B[i,j] % Xmul[j] == _sage_const_0 
                v = ZZ(B[i,j] // Xmul[j])
                h_tmp += v * monomials[j]
        h.append(h_tmp)

    x_ = [ var(f'x{i}') for i in range(n) ]
    for ii in Combinations(range(len(h)), k=n):
        f = symbolic_expression([ h[i](x) for i in ii ]).function(x_)
        jac = jacobian(f, x_)
        v = vector([ t // _sage_const_2  for t in bounds ])
        for _ in range(_sage_const_200 ):
            kwargs = {f'x{i}': v[i] for i in range(n)}
            tmp = v - jac(**kwargs).inverse() * f(**kwargs)
            v = vector((numerical_approx(d, prec=_sage_const_200 ) for d in tmp))
        v = [ int(_.round()) for _ in v ]
        if h[_sage_const_0 ](v) == _sage_const_0 :
            return v

    return []


N = _sage_const_0xc20d4f0792f162e3f3486f47c2c5b05696ba5c81ec09f5386bf741b7289b85e2d744559825a23b0ae094da214f3158344e5d5ba86fb1ecd1f40c8682a7bee55021eba772e23793001a38b9cccbfdc1d9316cccc3b79acd045c512b44e0f3697383958113a280791e17c23fe80fa38099e4907f70f4d228285aac69ed2d3bcf99 
hp = _sage_const_0xfe8984407b0816cc28e5ccc6bb73790000000000ca3806dd2cfdfc8d616b000000006109a4dbe3876b8d1b8adc9175dfba0e1ef318801648d60000000000a05b 

PR = PolynomialRing(Zmod(N), _sage_const_3 , names=('x0', 'x1', 'x2',)); (x0, x1, x2,) = PR._first_ngens(3)
f = hp + _sage_const_2 **_sage_const_16 *x0 + _sage_const_2 **_sage_const_240 *x1 + _sage_const_2 **_sage_const_352 *x2
x0, x1, x2 = coppersmith(f, bounds=(_sage_const_2 **_sage_const_40 ,_sage_const_2 **_sage_const_32 ,_sage_const_2 **_sage_const_40 ,), m=_sage_const_6 )
p = int(f(x0,x1,x2))
print(p)

