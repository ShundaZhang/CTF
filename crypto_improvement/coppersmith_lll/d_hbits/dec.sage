#e*d =  1 mod (p-1)*(q-1)
#3*d = 1 + k*(p-1)*(q-1)
#3*ld*p = p + k*n*p - k*p^2 - k*n + k*p mod 2^512

n = 92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183

c = 56164378185049402404287763972280630295410174183649054805947329504892979921131852321281317326306506444145699012788547718091371389698969718830761120076359634262880912417797038049510647237337251037070369278596191506725812511682495575589039521646062521091457438869068866365907962691742604895495670783101319608530

ld = 787673996295376297668171075170955852109814939442242049800811601753001897317556022653997651874897208487913321031340711138331360350633965420642045383644955

mp = []


#for k in range(1, 10):
for k in range(1, 4):
	p = var('p')
	p0 = solve_mod([3*p*ld == p + k*(n*p - p^2 - n + p)], 2^512)
	mp += [int(x[0]) for x in p0]

print(mp)

for lp in mp:
	R.<x> = PolynomialRing(Zmod(n))
	P = x*2^512 + lp
	root = P.monic().small_roots(X = 2^128, beta = 0.4)
	if root:
		p = int(P(root[0]))
		q = n//p
		phi = (p-1)*(q-1)
		d = inverse_mod(3, phi)
		m = pow(c, d, n)
		print(bytes.fromhex(hex(int(m))[2:]))
